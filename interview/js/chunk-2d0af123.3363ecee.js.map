{"version":3,"sources":["webpack:///./src/components/content/Promise.vue","webpack:///./src/textConfig/js/promise.js","webpack:///./src/components/content/Promise.vue?9dc3"],"names":["class","contents","promiseContent","data","promise","components","Parse","__exports__","render"],"mappings":"4IACSA,MAAM,c,qGAAX,gCAEM,MAFN,EAEM,CADF,yBAAoC,GAA5BC,SAAU,EAAAC,gBAAc,uB,gBCFzB,02GDSA,GACXC,KADW,WAEP,MAAO,CACHD,eAAAE,IAGRC,WAAY,CACRC,QAAA,O,qBEXR,MAAMC,EAA2B,IAAgB,EAAQ,CAAC,CAAC,SAASC,KAErD","file":"js/chunk-2d0af123.3363ecee.js","sourcesContent":["<template>\n    <div class=\"promiseBox\">\n        <Parse :contents=\"promiseContent\" />\n    </div>\n</template>\n<script>\nimport Parse from '@/components/common/Parse.vue'\nimport promiseContent from '@/textConfig/js/promise.js'\n\nexport default {\n    data() {\n        return {\n            promiseContent\n        }\n    },\n    components: {\n        Parse,\n    }\n}\n</script>\n","export default [\r\n`h3$$Promise需要注意的几个点`,\r\n`markdown$$ * Promise共有三种状态，也只能是三种状态的一种\r\n * Promise返回值后可以使用then和catch调用，调用后会返回新的Promise（也可以和原来的Promise一样Promise/A+）\r\n * catch是then(null, onRejected)的另一种写法，reject的值若未处理会一直传递给下一个Promise\r\n * 通常使用的Promise链式调用的返回对象和原Promise不同(假定返回的为Promise2)，但Promise2会返回onFulfilled(value)的值\r\n * Promise属于微任务，但new一个Promise会立即执行\r\n\r\n![promise](https://mdn.mozillademos.org/files/8633/promises.png)  \r\n\r\n详细的介绍可以查看[Promise/A+](https://promisesaplus.com/)\r\n`,\r\n`$$使用方法和注意项可以看以下这几个例子`,\r\n`code$$    /*常见的问题: 执行顺序*/\r\n    console.log(1)\r\n    setTimeout(() => console.log(2), 0)\r\n    new Promise((resolve, reject) => {\r\n        console.log(3)\r\n        setTimeout(() => resolve(4), 0)\r\n        setTimeout(() => console.log(5))\r\n    }).then(data => {\r\n        console.log(data)\r\n    })\r\n\r\n    /* result: 1, 3, 2, 4, 5*/\r\n\r\n    /* 下面函数的执行顺序，如果resolve和reject调换顺序，结果又是什么*/\r\n    new Promise((resolve, reject) => {\r\n        resolve(1) // reject(2)  \r\n        reject(2)  // resolve(1)\r\n    }).catch(data =>{\r\n         console.log(\"err\",data)\r\n    }).then(data => {\r\n        console.log(\"success\",data)\r\n    })\r\n    \r\n    /* result: success 1*/\r\n    /*调换顺序后: err 2, success undefined */\r\n`,\r\n`h3$$如何自己写一个promise`,\r\n`$$先查看Promise的规范，了解它是如何运作的，写一个简易的Promise就很简单了`,\r\n`code$$ /*未添加try{} catch(){}, 还有一些细节处理*/\r\nfunction promise(executor) {\r\n         \r\n    const resolve = value => {\r\n        if (this.state === 'REJECTED') return\r\n        this.state = 'FULLFILLED'\r\n        this.result = value\r\n        this.fullfill.forEach((onResolve, index) => {\r\n            const x = onResolve.call(undefined, value)\r\n            if (typeof x == 'object' && x.constructor == promise) {\r\n                x.then(this.xValue[index])\r\n            } else {\r\n                this.xValue[index](x)\r\n            }\r\n        })\r\n    }\r\n    const reject = reason => {\r\n        if (this.state === 'FULLFILLED') return\r\n        this.state = 'REJECTED'\r\n        this.result = reason\r\n        this.reject.forEach(onReject => {\r\n            onReject.call(undefined, reason)\r\n        })\r\n    }\r\n    this.state = \"PENDING\"\r\n    this.fullfill = []           // 模拟异步resolve\r\n    this.reject = []             //模拟一步reject\r\n    this.xValue = []             // 模拟返回异步fullfilled的结果\r\n    executor(resolve, reject)\r\n}\r\n\r\npromise.prototype.then = function(onResolve, onReject) {\r\n    const {state, result} = this\r\n    let meetFullfillDemand = typeof onResolve === 'function',\r\n        meetRejectDemand = typeof onReject === 'function'\r\n\r\n    return new promise((resolve, reject) => {\r\n        if(!meetRejectDemand && state === \"REJECTED\") {\r\n            reject(result)\r\n        } else if(!meetFullfillDemand && state === \"FULLFILLED\") {\r\n            resolve(result)\r\n        }\r\n        if(state == \"FULLFILLED\" && meetFullfillDemand) {\r\n            const x = onResolve.call(undefined, result)\r\n            if (typeof x == 'object'&& x.constructor == promise) {\r\n                x.then(resolve, reject)\r\n            }else{\r\n               resolve(x)\r\n            }\r\n        } else if(meetFullfillDemand) {\r\n            this.fullfill.push(onResolve)\r\n            this.xValue.push(resolve)\r\n        }\r\n        if(state == \"REJECTED\"&& meetRejectDemand) {\r\n            onReject.call(undefined, result)\r\n        } else if(meetRejectDemand) {\r\n            this.reject.push(onReject)\r\n        }\r\n    })\r\n}\r\n\r\npromise.prototype.catch = function(onReject) {\r\n    return this.then(null, onReject)\r\n}\r\n`,\r\n]","import { render } from \"./Promise.vue?vue&type=template&id=11453f66\"\nimport script from \"./Promise.vue?vue&type=script&lang=js\"\nexport * from \"./Promise.vue?vue&type=script&lang=js\"\n\nimport exportComponent from \"D:\\\\vue-project\\\\interview\\\\node_modules\\\\vue-loader-v16\\\\dist\\\\exportHelper.js\"\nconst __exports__ = /*#__PURE__*/exportComponent(script, [['render',render]])\n\nexport default __exports__"],"sourceRoot":""}