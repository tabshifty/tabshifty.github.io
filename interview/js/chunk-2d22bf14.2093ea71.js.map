{"version":3,"sources":["webpack:///./src/components/content/Copy.vue","webpack:///./src/textConfig/js/copy.js","webpack:///./src/components/content/Copy.vue?c0a5"],"names":["class","codeLanguge","rawCode","copyjs","code","shadow","mdSource","markdown","deep","shadowcode","shadowMd","deepCode","deepMd","data","copy","components","CodeSnippet","Text","__exports__","render"],"mappings":"0IACSA,MAAM,U,EACP,gCAAY,UAAR,OAAG,G,EACP,gCAEI,SAFD,6EAEH,G,EACA,gCAEI,SAFD,UAEH,G,EAEA,gCAEI,SAFD,WAEH,G,EAEA,gCAAY,UAAR,OAAG,G,EACP,gCAEI,SAFD,sDAEH,G,EACA,gCAEI,SAFD,UAEH,G,EAEA,gCAEI,SAFD,WAEH,G,mJAvBJ,gCAyBM,MAzBN,EAyBM,CAxBF,EACA,EAGA,EAGA,yBAAsE,GAAzDC,YAAY,aAAcC,QAAS,EAAAC,OAAOC,KAAKC,Q,oBAC5D,EAGA,yBAA0C,GAAnCC,SAAU,EAAAH,OAAOI,SAASF,Q,qBACjC,EACA,EAGA,EAGA,yBAAoE,GAAvDJ,YAAY,aAAcC,QAAS,EAAAC,OAAOC,KAAKI,M,oBAC5D,EAGA,yBAAwC,GAAjCF,SAAU,EAAAH,OAAOI,SAASC,M,uCCzBnCC,EAAU,4KAUVC,EAAW,uLAMXC,EAAW,0TAcXC,EAAS,qGAKA,GACXR,KAAM,CACFC,OAAQI,EACRD,KAAMG,GAEVJ,SAAU,CACNF,OAAQK,EACRF,KAAMI,I,YDTC,GACXC,KADW,WAEP,MAAO,CACHV,OAAAW,IAGRC,WAAY,CACRC,cAAA,KACAC,OAAA,O,qBEpCR,MAAMC,EAA2B,IAAgB,EAAQ,CAAC,CAAC,SAASC,KAErD","file":"js/chunk-2d22bf14.2093ea71.js","sourcesContent":["<template>\r\n    <div class=\"copBox\">\r\n        <h3>浅拷贝</h3>\r\n        <p>\r\n            浅拷贝只在第一层对属性进行赋值操作，如果属性是基本数据则直接赋值(存放在栈内存中)，如果是引用类型则对指针地址进行赋值，实际的值存放在堆内存中\r\n        </p>\r\n        <p>\r\n            代码参考\r\n        </p>\r\n        <CodeSnippet codeLanguge=\"javascript\" :rawCode=\"copyjs.code.shadow\" />\r\n        <p>\r\n            其他方式:\r\n        </p>\r\n        <Text :mdSource=\"copyjs.markdown.shadow\"/>\r\n        <h3>深拷贝</h3>\r\n        <p>\r\n            深拷贝在赋值是类似于每层的对象属性都会进行新建一个对象进行拷贝, 复制整个对象，返回新的引用指针\r\n        </p>\r\n        <p>\r\n            代码参考\r\n        </p>\r\n        <CodeSnippet codeLanguge=\"javascript\" :rawCode=\"copyjs.code.deep\" />\r\n        <p>\r\n            其他方式:\r\n        </p>\r\n        <Text :mdSource=\"copyjs.markdown.deep\"/>\r\n    </div>\r\n</template>\r\n<script>\r\nimport CodeSnippet from '@/components/common/CodeSnippet.vue'\r\nimport copyjs from '@/textConfig/js/copy.js'\r\nimport Text from '@/components/common/Text.vue'\r\n\r\nexport default {\r\n    data() {\r\n        return {\r\n            copyjs\r\n        }\r\n    },\r\n    components: {\r\n        CodeSnippet,\r\n        Text\r\n    }\r\n}\r\n</script>\r\n\r\n<style scoped>\r\n\r\n</style>","const shadowcode =\r\n`// 浅拷贝简单的实现代码\r\nconst shadowCopy = function(clone) {\r\n    const cloned = {}\r\n    for (let key in clone) {\r\n        cloned[key] = clone[key]\r\n    }\r\n    return cloned\r\n}\r\n`\r\nconst shadowMd = \r\n` 1. 使用Object.assign()的方法实现, 但当对象只有一层基础类型的数据时属于深拷贝\r\n 2. 展开运算符是一个 es6 / es2015特性，它提供了一种非常方便的方式来执行浅拷贝，与 Object.assign ()的功能相同\r\n 3. Array.prototype.concat() 和 Array.prototype.slice()\r\n`\r\n//深拷贝简单的实现代码\r\nconst deepCode = \r\n`const deepCopy = function(clone) {\r\n    const cloned = Array.isArray(clone) ? [] : {}\r\n    for (let key in clone) {   \r\n        if (typeof clone[key] === 'object') {\r\n            cloned[key] = deepCopy(clone[key])\r\n        } else {\r\n            cloned[key] = clone[key]\r\n        }\r\n    }\r\n    return cloned\r\n}\r\n`\r\n\r\nconst deepMd = \r\n` 1. 用JSON.stringify把对象转成字符串，再用JSON.parse把字符串转成新的对象(可以转成JSON格式的对象才可以这样用)\r\n 2. 使用Object.create()方法\r\n`\r\n\r\nexport default {\r\n    code: {\r\n        shadow: shadowcode,\r\n        deep: deepCode\r\n    },\r\n    markdown: {\r\n        shadow: shadowMd,\r\n        deep: deepMd\r\n    }\r\n}","import { render } from \"./Copy.vue?vue&type=template&id=335be830\"\nimport script from \"./Copy.vue?vue&type=script&lang=js\"\nexport * from \"./Copy.vue?vue&type=script&lang=js\"\n\nimport exportComponent from \"D:\\\\vue-project\\\\interview\\\\node_modules\\\\vue-loader-v16\\\\dist\\\\exportHelper.js\"\nconst __exports__ = /*#__PURE__*/exportComponent(script, [['render',render]])\n\nexport default __exports__"],"sourceRoot":""}