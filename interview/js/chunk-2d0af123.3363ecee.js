(window["webpackJsonp"]=window["webpackJsonp"]||[]).push([["chunk-2d0af123"],{"0d81":function(e,n,t){"use strict";t.r(n);var o=t("7a23"),s={class:"promiseBox"};function l(e,n,t,l,r,c){var i=Object(o["resolveComponent"])("Parse");return Object(o["openBlock"])(),Object(o["createElementBlock"])("div",s,[Object(o["createVNode"])(i,{contents:r.promiseContent},null,8,["contents"])])}var r=t("9de1"),c=["h3$$Promise需要注意的几个点","markdown$$ * Promise共有三种状态，也只能是三种状态的一种\n * Promise返回值后可以使用then和catch调用，调用后会返回新的Promise（也可以和原来的Promise一样Promise/A+）\n * catch是then(null, onRejected)的另一种写法，reject的值若未处理会一直传递给下一个Promise\n * 通常使用的Promise链式调用的返回对象和原Promise不同(假定返回的为Promise2)，但Promise2会返回onFulfilled(value)的值\n * Promise属于微任务，但new一个Promise会立即执行\n\n![promise](https://mdn.mozillademos.org/files/8633/promises.png)  \n\n详细的介绍可以查看[Promise/A+](https://promisesaplus.com/)\n","$$使用方法和注意项可以看以下这几个例子",'code$$    /*常见的问题: 执行顺序*/\n    console.log(1)\n    setTimeout(() => console.log(2), 0)\n    new Promise((resolve, reject) => {\n        console.log(3)\n        setTimeout(() => resolve(4), 0)\n        setTimeout(() => console.log(5))\n    }).then(data => {\n        console.log(data)\n    })\n\n    /* result: 1, 3, 2, 4, 5*/\n\n    /* 下面函数的执行顺序，如果resolve和reject调换顺序，结果又是什么*/\n    new Promise((resolve, reject) => {\n        resolve(1) // reject(2)  \n        reject(2)  // resolve(1)\n    }).catch(data =>{\n         console.log("err",data)\n    }).then(data => {\n        console.log("success",data)\n    })\n    \n    /* result: success 1*/\n    /*调换顺序后: err 2, success undefined */\n',"h3$$如何自己写一个promise","$$先查看Promise的规范，了解它是如何运作的，写一个简易的Promise就很简单了","code$$ /*未添加try{} catch(){}, 还有一些细节处理*/\nfunction promise(executor) {\n         \n    const resolve = value => {\n        if (this.state === 'REJECTED') return\n        this.state = 'FULLFILLED'\n        this.result = value\n        this.fullfill.forEach((onResolve, index) => {\n            const x = onResolve.call(undefined, value)\n            if (typeof x == 'object' && x.constructor == promise) {\n                x.then(this.xValue[index])\n            } else {\n                this.xValue[index](x)\n            }\n        })\n    }\n    const reject = reason => {\n        if (this.state === 'FULLFILLED') return\n        this.state = 'REJECTED'\n        this.result = reason\n        this.reject.forEach(onReject => {\n            onReject.call(undefined, reason)\n        })\n    }\n    this.state = \"PENDING\"\n    this.fullfill = []           // 模拟异步resolve\n    this.reject = []             //模拟一步reject\n    this.xValue = []             // 模拟返回异步fullfilled的结果\n    executor(resolve, reject)\n}\n\npromise.prototype.then = function(onResolve, onReject) {\n    const {state, result} = this\n    let meetFullfillDemand = typeof onResolve === 'function',\n        meetRejectDemand = typeof onReject === 'function'\n\n    return new promise((resolve, reject) => {\n        if(!meetRejectDemand && state === \"REJECTED\") {\n            reject(result)\n        } else if(!meetFullfillDemand && state === \"FULLFILLED\") {\n            resolve(result)\n        }\n        if(state == \"FULLFILLED\" && meetFullfillDemand) {\n            const x = onResolve.call(undefined, result)\n            if (typeof x == 'object'&& x.constructor == promise) {\n                x.then(resolve, reject)\n            }else{\n               resolve(x)\n            }\n        } else if(meetFullfillDemand) {\n            this.fullfill.push(onResolve)\n            this.xValue.push(resolve)\n        }\n        if(state == \"REJECTED\"&& meetRejectDemand) {\n            onReject.call(undefined, result)\n        } else if(meetRejectDemand) {\n            this.reject.push(onReject)\n        }\n    })\n}\n\npromise.prototype.catch = function(onReject) {\n    return this.then(null, onReject)\n}\n"],i={data:function(){return{promiseContent:c}},components:{Parse:r["a"]}},a=t("6b0d"),u=t.n(a);const m=u()(i,[["render",l]]);n["default"]=m}}]);
//# sourceMappingURL=chunk-2d0af123.3363ecee.js.map